<h1><b><p align="center">Training Level 2</p></b></h1>


### 1. Complexity Analysis
- Learn to evaluate the efficiency of algorithms by understanding Big O notation.
- This is critical for optimizing code and making it scalable.


### 2. Recursion
- Understand the concept of recursion and its role in solving complex problems.
- Learn how to employ recursion effectively within your code.


### 3. Conditions
- Learn how to make decisions in your code using conditional statements.
- Explore the world of branching and decision-making in programming.

### 4. Frequency Array (Counting and Sorting)
- Discover techniques for handling data efficiently by counting occurrences and sorting them using simple arrays.
- This is especially useful in scenarios where you need quick look-ups and
sorted data.

### 5. Prefix Sum (1D Basic, Update Range, 2D)
- Gain proficiency in using prefix sums to calculate cumulative sums efficiently, which is invaluable in solving range query problems and in image processing tasks.

### 6. Vectors and Iterators
- Understand dynamic arrays (vectors) and how iterators can manipulate these arrays efficiently. 
- This is fundamental in C++ STL and helps manage data flexibly.

### 7. Linear Data Structures (Stack, Queue, Deque, Priority Queue)
- Master these structures to manage data elements in a linear order, each with its specific use case like undo mechanisms (stacks) or scheduling (queues).

### 8. Non-Linear Data Structures (Set, Multiset, Ordered Set, Map, Multimap, Unordered Map)
- Explore these structures for more complex data relations and quick data retrieval, insertion, and deletion, crucial for performance in dynamic data handling.

### 9. Sorting Techniques (Bubble, Insertion, Selection, Merge, Quick Sort)
- Understand various sorting algorithms, their complexities, and practical applications to choose the best sort mechanism for your data.

### 10. Sorting with a Custom Touch (Compare Function)
- Learn to customize sorting operations using compare functions, enabling tailored sorting criteria for specific needs.

### 11. Binary Search (Basic, Binary Search in Doubles, Lower Bound, Upper Bound)
- Delve into binary search techniques to quickly find elements or boundaries in a sorted array, reducing search complexity significantly.

### 12. Two Pointers
- Master two-pointer techniques to solve problems efficiently where elements in sequences need to be compared or combined.

### 13. Bitmask
- Investigate the use of bitmasking for compactly storing and manipulating data with bit-level operations, useful in solving complex problems involving subsets or configurations.